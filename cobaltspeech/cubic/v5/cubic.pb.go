// Copyright (2022--present) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        (unknown)
// source: cobaltspeech/cubic/v5/cubic.proto

package cubicv5

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Byte order of multi-byte data
type ByteOrder int32

const (
	// BYTE_ORDER_UNSPECIFIED is the default value of this type.
	ByteOrder_BYTE_ORDER_UNSPECIFIED ByteOrder = 0
	// Little Endian byte order
	ByteOrder_BYTE_ORDER_LITTLE_ENDIAN ByteOrder = 1
	// Big Endian byte order
	ByteOrder_BYTE_ORDER_BIG_ENDIAN ByteOrder = 2
)

// Enum value maps for ByteOrder.
var (
	ByteOrder_name = map[int32]string{
		0: "BYTE_ORDER_UNSPECIFIED",
		1: "BYTE_ORDER_LITTLE_ENDIAN",
		2: "BYTE_ORDER_BIG_ENDIAN",
	}
	ByteOrder_value = map[string]int32{
		"BYTE_ORDER_UNSPECIFIED":   0,
		"BYTE_ORDER_LITTLE_ENDIAN": 1,
		"BYTE_ORDER_BIG_ENDIAN":    2,
	}
)

func (x ByteOrder) Enum() *ByteOrder {
	p := new(ByteOrder)
	*p = x
	return p
}

func (x ByteOrder) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ByteOrder) Descriptor() protoreflect.EnumDescriptor {
	return file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[0].Descriptor()
}

func (ByteOrder) Type() protoreflect.EnumType {
	return &file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[0]
}

func (x ByteOrder) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ByteOrder.Descriptor instead.
func (ByteOrder) EnumDescriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{0}
}

// The encoding of the audio data to be sent for recognition.
type AudioEncoding int32

const (
	// AUDIO_ENCODING_UNSPECIFIED is the default value of this type and will
	// result in an error.
	AudioEncoding_AUDIO_ENCODING_UNSPECIFIED AudioEncoding = 0
	// PCM signed-integer
	AudioEncoding_AUDIO_ENCODING_SIGNED AudioEncoding = 1
	// PCM unsigned-integer
	AudioEncoding_AUDIO_ENCODING_UNSIGNED AudioEncoding = 2
	// PCM IEEE-Float
	AudioEncoding_AUDIO_ENCODING_IEEE_FLOAT AudioEncoding = 3
	// G.711 mu-law
	AudioEncoding_AUDIO_ENCODING_ULAW AudioEncoding = 4
	// G.711 a-law
	AudioEncoding_AUDIO_ENCODING_ALAW AudioEncoding = 5
)

// Enum value maps for AudioEncoding.
var (
	AudioEncoding_name = map[int32]string{
		0: "AUDIO_ENCODING_UNSPECIFIED",
		1: "AUDIO_ENCODING_SIGNED",
		2: "AUDIO_ENCODING_UNSIGNED",
		3: "AUDIO_ENCODING_IEEE_FLOAT",
		4: "AUDIO_ENCODING_ULAW",
		5: "AUDIO_ENCODING_ALAW",
	}
	AudioEncoding_value = map[string]int32{
		"AUDIO_ENCODING_UNSPECIFIED": 0,
		"AUDIO_ENCODING_SIGNED":      1,
		"AUDIO_ENCODING_UNSIGNED":    2,
		"AUDIO_ENCODING_IEEE_FLOAT":  3,
		"AUDIO_ENCODING_ULAW":        4,
		"AUDIO_ENCODING_ALAW":        5,
	}
)

func (x AudioEncoding) Enum() *AudioEncoding {
	p := new(AudioEncoding)
	*p = x
	return p
}

func (x AudioEncoding) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AudioEncoding) Descriptor() protoreflect.EnumDescriptor {
	return file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[1].Descriptor()
}

func (AudioEncoding) Type() protoreflect.EnumType {
	return &file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[1]
}

func (x AudioEncoding) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AudioEncoding.Descriptor instead.
func (AudioEncoding) EnumDescriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{1}
}

type AudioFormat_Type int32

const (
	// TYPE_UNSPECIFIED is the default value of this type.
	AudioFormat_TYPE_UNSPECIFIED AudioFormat_Type = 0
	// Raw audio samples. The `raw` field must be set when this format is used.
	AudioFormat_TYPE_RAW AudioFormat_Type = 1
	// WAV with a RIFF header
	AudioFormat_TYPE_WAV AudioFormat_Type = 2
	// MP3 format with a valid frame header at the beginning of data
	AudioFormat_TYPE_MP3 AudioFormat_Type = 3
	// FLAC format with a valid header
	AudioFormat_TYPE_FLAC AudioFormat_Type = 4
	// Opus format with an OGG header
	AudioFormat_TYPE_OGG_OPUS AudioFormat_Type = 5
)

// Enum value maps for AudioFormat_Type.
var (
	AudioFormat_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "TYPE_RAW",
		2: "TYPE_WAV",
		3: "TYPE_MP3",
		4: "TYPE_FLAC",
		5: "TYPE_OGG_OPUS",
	}
	AudioFormat_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"TYPE_RAW":         1,
		"TYPE_WAV":         2,
		"TYPE_MP3":         3,
		"TYPE_FLAC":        4,
		"TYPE_OGG_OPUS":    5,
	}
)

func (x AudioFormat_Type) Enum() *AudioFormat_Type {
	p := new(AudioFormat_Type)
	*p = x
	return p
}

func (x AudioFormat_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AudioFormat_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[2].Descriptor()
}

func (AudioFormat_Type) Type() protoreflect.EnumType {
	return &file_cobaltspeech_cubic_v5_cubic_proto_enumTypes[2]
}

func (x AudioFormat_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AudioFormat_Type.Descriptor instead.
func (AudioFormat_Type) EnumDescriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{9, 0}
}

// The top-level message sent by the client for the `Version` method.
type VersionRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *VersionRequest) Reset() {
	*x = VersionRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VersionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionRequest) ProtoMessage() {}

func (x *VersionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionRequest.ProtoReflect.Descriptor instead.
func (*VersionRequest) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{0}
}

// The message sent by the server for the `Version` method.
type VersionResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Version of the server handling these requests.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *VersionResponse) Reset() {
	*x = VersionResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VersionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionResponse) ProtoMessage() {}

func (x *VersionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionResponse.ProtoReflect.Descriptor instead.
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{1}
}

func (x *VersionResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

// The top-level message sent by the client for the `ListModels` method.
type ListModelsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ListModelsRequest) Reset() {
	*x = ListModelsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListModelsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListModelsRequest) ProtoMessage() {}

func (x *ListModelsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListModelsRequest.ProtoReflect.Descriptor instead.
func (*ListModelsRequest) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{2}
}

// The message returned to the client by the `ListModels` method.
type ListModelsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of models available for use that match the request.
	Models []*Model `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
}

func (x *ListModelsResponse) Reset() {
	*x = ListModelsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListModelsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListModelsResponse) ProtoMessage() {}

func (x *ListModelsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListModelsResponse.ProtoReflect.Descriptor instead.
func (*ListModelsResponse) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{3}
}

func (x *ListModelsResponse) GetModels() []*Model {
	if x != nil {
		return x.Models
	}
	return nil
}

// The top-level messages sent by the client for the `StreamingRecognize`
// method. In this streaming call, multiple `StreamingRecognizeRequest` messages
// should be sent. The first message must contain a `RecognitionConfig` message
// only, and all subsequent messages must contain `RecognitionAudio` only. All
// `RecognitionAudio` messages must contain non-empty audio. If audio content is
// empty, the server may choose to interpret it as end of stream and stop
// accepting any further messages.
type StreamingRecognizeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Request:
	//	*StreamingRecognizeRequest_Config
	//	*StreamingRecognizeRequest_Audio
	Request isStreamingRecognizeRequest_Request `protobuf_oneof:"request"`
}

func (x *StreamingRecognizeRequest) Reset() {
	*x = StreamingRecognizeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StreamingRecognizeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognizeRequest) ProtoMessage() {}

func (x *StreamingRecognizeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognizeRequest.ProtoReflect.Descriptor instead.
func (*StreamingRecognizeRequest) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{4}
}

func (m *StreamingRecognizeRequest) GetRequest() isStreamingRecognizeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (x *StreamingRecognizeRequest) GetConfig() *RecognitionConfig {
	if x, ok := x.GetRequest().(*StreamingRecognizeRequest_Config); ok {
		return x.Config
	}
	return nil
}

func (x *StreamingRecognizeRequest) GetAudio() *RecognitionAudio {
	if x, ok := x.GetRequest().(*StreamingRecognizeRequest_Audio); ok {
		return x.Audio
	}
	return nil
}

type isStreamingRecognizeRequest_Request interface {
	isStreamingRecognizeRequest_Request()
}

type StreamingRecognizeRequest_Config struct {
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3,oneof"`
}

type StreamingRecognizeRequest_Audio struct {
	Audio *RecognitionAudio `protobuf:"bytes,2,opt,name=audio,proto3,oneof"`
}

func (*StreamingRecognizeRequest_Config) isStreamingRecognizeRequest_Request() {}

func (*StreamingRecognizeRequest_Audio) isStreamingRecognizeRequest_Request() {}

// The messages returned by the server for the `StreamingRecognize` request.
// Multiple messages of this type will be delivered on the stream, for multiple
// results, as soon as results are available from the audio submitted so far. If
// the audio has multiple channels, the results of all channels will be
// interleaved. Results of each individual channel will be chronological.
// However, there is no guarantee of the order of results across channels.
//
// Clients should process both the `result` and `error` fields in each message.
// At least one of these fields will be present in the message. If both `result`
// and `error` are present, the result is still valid.
type StreamingRecognizeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A new recognition result. This field will be unset if a new result is not
	// yet available.
	Result *RecognitionResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// A non-fatal error message. If a server encountered a non-fatal error when
	// processing the recognition request, it will be returned in this message.
	// The server will continue to process audio and produce further results.
	// Clients can continue streaming audio even after receiving these messages.
	// This error message is meant to be informational.
	//
	// An example of when these errors maybe produced: audio is sampled at a lower
	// rate than expected by model, producing possibly less accurate results.
	//
	// This field will be unset if there is no error to report.
	Error *RecognitionError `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *StreamingRecognizeResponse) Reset() {
	*x = StreamingRecognizeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StreamingRecognizeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognizeResponse) ProtoMessage() {}

func (x *StreamingRecognizeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognizeResponse.ProtoReflect.Descriptor instead.
func (*StreamingRecognizeResponse) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{5}
}

func (x *StreamingRecognizeResponse) GetResult() *RecognitionResult {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *StreamingRecognizeResponse) GetError() *RecognitionError {
	if x != nil {
		return x.Error
	}
	return nil
}

// The top-level message sent by the client for the `CompileContext` request. It
// contains a list of phrases or words, paired with a context token included in
// the model being used. The token specifies a category such as "menu_item",
// "airport", "contact", "product_name" etc. The context token is used to
// determine the places in the recognition output where the provided list of
// phrases or words may appear. The allowed context tokens for a given model can
// be found in its `ModelAttributes.ContextInfo` obtained via the `ListModels`
// method.
type CompileContextRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique identifier of the model to compile the context information for. The
	// model chosen needs to support context which can be verified by checking its
	// `ModelAttributes.ContextInfo` obtained via `ListModels`.
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// The token that is associated with the provided list of phrases or words
	// (e.g "menu_item", "airport" etc.). Must be one of the tokens included in
	// the model being used, which can be retrieved by calling the `ListModels`
	// method.
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// List of phrases and/or words to be compiled.
	Phrases []*ContextPhrase `protobuf:"bytes,3,rep,name=phrases,proto3" json:"phrases,omitempty"`
}

func (x *CompileContextRequest) Reset() {
	*x = CompileContextRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompileContextRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompileContextRequest) ProtoMessage() {}

func (x *CompileContextRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompileContextRequest.ProtoReflect.Descriptor instead.
func (*CompileContextRequest) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{6}
}

func (x *CompileContextRequest) GetModelId() string {
	if x != nil {
		return x.ModelId
	}
	return ""
}

func (x *CompileContextRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *CompileContextRequest) GetPhrases() []*ContextPhrase {
	if x != nil {
		return x.Phrases
	}
	return nil
}

// The message returned to the client by the `CompileContext` method.
type CompileContextResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Context information in a compact form that is efficient for use in
	// subsequent recognition requests. The size of the compiled form will depend
	// on the amount of text that was sent for compilation. For 1000 words it's
	// generally less than 100 kilobytes.
	Context *CompiledContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
}

func (x *CompileContextResponse) Reset() {
	*x = CompileContextResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompileContextResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompileContextResponse) ProtoMessage() {}

func (x *CompileContextResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompileContextResponse.ProtoReflect.Descriptor instead.
func (*CompileContextResponse) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{7}
}

func (x *CompileContextResponse) GetContext() *CompiledContext {
	if x != nil {
		return x.Context
	}
	return nil
}

// Configuration for setting up a Recognizer
type RecognitionConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique identifier of the model to use, as obtained from a `Model` message.
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// Format of the audio to be sent for recognition.
	//
	// Depending on how they are configured, server instances of this service may
	// not support all the formats provided in the API. One format that is
	// guaranteed to be supported is the RAW format with little-endian 16-bit
	// signed samples with the sample rate matching that of the model being
	// requested.
	AudioFormat *AudioFormat `protobuf:"bytes,2,opt,name=audio_format,json=audioFormat,proto3" json:"audio_format,omitempty"`
	// This is an optional field. If the audio has multiple channels, this field
	// can be configured with the list of channel indices that should be
	// considered for the recognition task. These channels are 0-indexed.
	//
	// Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
	// Example: `[1]` to only transcribe the second channel of a stereo file.
	//
	// If this field is not set, all the channels in the audio will be processed.
	//
	// Channels that are present in the audio may be omitted, but it is an error
	// to include a channel index in this field that is not present in the audio.
	// Channels may be listed in any order but the same index may not be repeated
	// in this list.
	//
	// BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
	SelectedAudioChannels []uint32 `protobuf:"varint,3,rep,packed,name=selected_audio_channels,json=selectedAudioChannels,proto3" json:"selected_audio_channels,omitempty"`
	// This is an optional field. It can be used to indicate that the audio being
	// streamed to the recognizer is offset from the original stream by the
	// provided duration in milliseconds. This offset will be added to all
	// timestamps in results returned by the recognizer.
	//
	// The default value of this field is 0ms, so the timestamps in the
	// recognition result will not be modified.
	//
	// Example use case where this field can be helpful: if a recognition session
	// was interrupted and audio needs to be sent to a new session from the point
	// where the session was previously interrupted, the offset could be set to
	// the point where the interruption had happened.
	AudioTimeOffsetMs uint64 `protobuf:"varint,4,opt,name=audio_time_offset_ms,json=audioTimeOffsetMs,proto3" json:"audio_time_offset_ms,omitempty"`
	// This is an optional field. If this is set to `true`, each result will
	// include word level details of the transcript. These details are specified
	// in the `WordDetails` message. If set to `false`, no word-level details will
	// be returned. The default is `false`.
	EnableWordDetails bool `protobuf:"varint,5,opt,name=enable_word_details,json=enableWordDetails,proto3" json:"enable_word_details,omitempty"`
	// This is an optional field. If this is set to true, each result will include
	// a confusion network. If set to `false`, no confusion network will be
	// returned. The default is `false`. If the model being used does not support
	// returning a confusion network, this field will have no effect. Tokens in
	// the confusion network always correspond to tokens in the `transcript_raw`
	// returned.
	EnableConfusionNetwork bool `protobuf:"varint,6,opt,name=enable_confusion_network,json=enableConfusionNetwork,proto3" json:"enable_confusion_network,omitempty"`
	// This is an optional field. If there is any metadata associated with the
	// audio being sent, use this field to provide it to the recognizer. The
	// server may record this metadata when processing the request. The server
	// does not use this field for any other purpose.
	Metadata *RecognitionMetadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// This is an optional field for providing any additional context information
	// that may aid speech recognition. This can also be used to add
	// out-of-vocabulary words to the model or boost recognition of specific
	// proper names or commands. Context information must be pre-compiled via the
	// `CompileContext()` method.
	Context *RecognitionContext `protobuf:"bytes,8,opt,name=context,proto3" json:"context,omitempty"`
}

func (x *RecognitionConfig) Reset() {
	*x = RecognitionConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionConfig) ProtoMessage() {}

func (x *RecognitionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionConfig.ProtoReflect.Descriptor instead.
func (*RecognitionConfig) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{8}
}

func (x *RecognitionConfig) GetModelId() string {
	if x != nil {
		return x.ModelId
	}
	return ""
}

func (x *RecognitionConfig) GetAudioFormat() *AudioFormat {
	if x != nil {
		return x.AudioFormat
	}
	return nil
}

func (x *RecognitionConfig) GetSelectedAudioChannels() []uint32 {
	if x != nil {
		return x.SelectedAudioChannels
	}
	return nil
}

func (x *RecognitionConfig) GetAudioTimeOffsetMs() uint64 {
	if x != nil {
		return x.AudioTimeOffsetMs
	}
	return 0
}

func (x *RecognitionConfig) GetEnableWordDetails() bool {
	if x != nil {
		return x.EnableWordDetails
	}
	return false
}

func (x *RecognitionConfig) GetEnableConfusionNetwork() bool {
	if x != nil {
		return x.EnableConfusionNetwork
	}
	return false
}

func (x *RecognitionConfig) GetMetadata() *RecognitionMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *RecognitionConfig) GetContext() *RecognitionContext {
	if x != nil {
		return x.Context
	}
	return nil
}

// Format of the audio. This allows specifying whether the audio is raw audio,
// or audio with a self-describing header.
//
// If sending raw audio, the `raw` field must be set to provide relevant
// details. For headered formats, the self-describing header must be present at
// the beginning of the stream, and not in every `RecognitionAudio` message.
type AudioFormat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Type of the audio format. If this field is not specified, but the `raw`
	// field is set, a value of TYPE_RAW will be assumed. Otherwise, the server
	// will attempt to detect one of the supported types with a self-describing
	// header. If this detection fails, an error will be returned.
	//
	// It is recommended that the type be explicitly specified.
	Type AudioFormat_Type `protobuf:"varint,1,opt,name=type,proto3,enum=cobaltspeech.cubic.v5.AudioFormat_Type" json:"type,omitempty"`
	// This field must not be set if the audio format has a self-describing
	// header. This field must be set when the type is TYPE_RAW.
	Raw *AudioFormatRaw `protobuf:"bytes,2,opt,name=raw,proto3" json:"raw,omitempty"`
}

func (x *AudioFormat) Reset() {
	*x = AudioFormat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AudioFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioFormat) ProtoMessage() {}

func (x *AudioFormat) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioFormat.ProtoReflect.Descriptor instead.
func (*AudioFormat) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{9}
}

func (x *AudioFormat) GetType() AudioFormat_Type {
	if x != nil {
		return x.Type
	}
	return AudioFormat_TYPE_UNSPECIFIED
}

func (x *AudioFormat) GetRaw() *AudioFormatRaw {
	if x != nil {
		return x.Raw
	}
	return nil
}

// Details of audio in raw format
type AudioFormatRaw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Encoding of the samples. It must be specified explicitly and using the
	// default value of `AUDIO_ENCODING_UNSPECIFIED` will result in an error.
	Encoding AudioEncoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=cobaltspeech.cubic.v5.AudioEncoding" json:"encoding,omitempty"`
	// Bit depth of each sample (e.g. 8, 16, 24, 32, etc.). This is a required
	// field.
	BitDepth uint32 `protobuf:"varint,2,opt,name=bit_depth,json=bitDepth,proto3" json:"bit_depth,omitempty"`
	// Byte order of the samples. This field must be set to a value other than
	// `BYTE_ORDER_UNSPECIFIED` when the `bit_depth` is greater than 8.
	ByteOrder ByteOrder `protobuf:"varint,3,opt,name=byte_order,json=byteOrder,proto3,enum=cobaltspeech.cubic.v5.ByteOrder" json:"byte_order,omitempty"`
	// Sampling rate in Hz. This is a required field.
	SampleRate uint32 `protobuf:"varint,4,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	// Number of channels present in the audio. E.g.: 1 (mono), 2 (stereo), etc.
	// This is a required field.
	Channels uint32 `protobuf:"varint,5,opt,name=channels,proto3" json:"channels,omitempty"`
}

func (x *AudioFormatRaw) Reset() {
	*x = AudioFormatRaw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AudioFormatRaw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioFormatRaw) ProtoMessage() {}

func (x *AudioFormatRaw) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioFormatRaw.ProtoReflect.Descriptor instead.
func (*AudioFormatRaw) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{10}
}

func (x *AudioFormatRaw) GetEncoding() AudioEncoding {
	if x != nil {
		return x.Encoding
	}
	return AudioEncoding_AUDIO_ENCODING_UNSPECIFIED
}

func (x *AudioFormatRaw) GetBitDepth() uint32 {
	if x != nil {
		return x.BitDepth
	}
	return 0
}

func (x *AudioFormatRaw) GetByteOrder() ByteOrder {
	if x != nil {
		return x.ByteOrder
	}
	return ByteOrder_BYTE_ORDER_UNSPECIFIED
}

func (x *AudioFormatRaw) GetSampleRate() uint32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

func (x *AudioFormatRaw) GetChannels() uint32 {
	if x != nil {
		return x.Channels
	}
	return 0
}

// Metadata associated with the audio to be recognized.
type RecognitionMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Any custom metadata that the client wants to associate with the recording.
	// This could be a simple string (e.g. a tracing ID) or structured data
	// (e.g. JSON).
	CustomMetadata string `protobuf:"bytes,1,opt,name=custom_metadata,json=customMetadata,proto3" json:"custom_metadata,omitempty"`
}

func (x *RecognitionMetadata) Reset() {
	*x = RecognitionMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionMetadata) ProtoMessage() {}

func (x *RecognitionMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionMetadata.ProtoReflect.Descriptor instead.
func (*RecognitionMetadata) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{11}
}

func (x *RecognitionMetadata) GetCustomMetadata() string {
	if x != nil {
		return x.CustomMetadata
	}
	return ""
}

// A collection of additional context information that may aid speech
// recognition. This can be used to add out-of-vocabulary words to the model or
// to boost recognition of specific proper names or commands.
type RecognitionContext struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of compiled context information, with each entry being compiled from a
	// list of words or phrases using the `CompileContext` method.
	Compiled []*CompiledContext `protobuf:"bytes,1,rep,name=compiled,proto3" json:"compiled,omitempty"`
}

func (x *RecognitionContext) Reset() {
	*x = RecognitionContext{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionContext) ProtoMessage() {}

func (x *RecognitionContext) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionContext.ProtoReflect.Descriptor instead.
func (*RecognitionContext) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{12}
}

func (x *RecognitionContext) GetCompiled() []*CompiledContext {
	if x != nil {
		return x.Compiled
	}
	return nil
}

// Context information in a compact form that is efficient for use in subsequent
// recognition requests. The size of the compiled form will depend on the amount
// of text that was sent for compilation. For 1000 words it's generally less
// than 100 kilobytes.
type CompiledContext struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The context information compiled by the `CompileContext` method.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *CompiledContext) Reset() {
	*x = CompiledContext{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompiledContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompiledContext) ProtoMessage() {}

func (x *CompiledContext) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompiledContext.ProtoReflect.Descriptor instead.
func (*CompiledContext) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{13}
}

func (x *CompiledContext) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// A phrase or word that is to be compiled into context information that can be
// later used to improve speech recognition during a `StreamingRecognize` call.
// Along with the phrase or word itself, there is an optional boost parameter
// that can be used to boost the likelihood of the phrase or word in the
// recognition output.
type ContextPhrase struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The actual phrase or word.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// This is an optional field. The boost factor is a positive number which is
	// used to multiply the probability of the phrase or word appearing in the
	// output. This setting can be used to differentiate between similar sounding
	// words, with the desired word given a bigger boost factor.
	//
	// By default, all phrases or words provided in the `RecongitionContext` are
	// given an equal probability of occurring. Boost factors larger than 1 make
	// the phrase or word more probable and boost factors less than 1 make it less
	// likely. A boost factor of 2 corresponds to making the phrase or word twice
	// as likely, while a boost factor of 0.5 means half as likely.
	Boost float32 `protobuf:"fixed32,2,opt,name=boost,proto3" json:"boost,omitempty"`
}

func (x *ContextPhrase) Reset() {
	*x = ContextPhrase{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContextPhrase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContextPhrase) ProtoMessage() {}

func (x *ContextPhrase) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContextPhrase.ProtoReflect.Descriptor instead.
func (*ContextPhrase) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{14}
}

func (x *ContextPhrase) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *ContextPhrase) GetBoost() float32 {
	if x != nil {
		return x.Boost
	}
	return 0
}

// Audio to be sent to the recognizer
type RecognitionAudio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *RecognitionAudio) Reset() {
	*x = RecognitionAudio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionAudio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionAudio) ProtoMessage() {}

func (x *RecognitionAudio) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionAudio.ProtoReflect.Descriptor instead.
func (*RecognitionAudio) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{15}
}

func (x *RecognitionAudio) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Description of a Cubic Model
type Model struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique identifier of the model. This identifier is used to choose the model
	// that should be used for recognition, and is specified in the
	// `RecognitionConfig` message.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Model name. This is a concise name describing the model, and may be
	// presented to the end-user, for example, to help choose which model to use
	// for their recognition task.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Model attributes
	Attributes *ModelAttributes `protobuf:"bytes,3,opt,name=attributes,proto3" json:"attributes,omitempty"`
}

func (x *Model) Reset() {
	*x = Model{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Model) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Model) ProtoMessage() {}

func (x *Model) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Model.ProtoReflect.Descriptor instead.
func (*Model) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{16}
}

func (x *Model) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Model) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Model) GetAttributes() *ModelAttributes {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Attributes of a Cubic Model
type ModelAttributes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Audio sample rate supported by the model
	SampleRate uint32 `protobuf:"varint,1,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	// Attributes specifc to supporting recognition context.
	ContextInfo *ContextInfo `protobuf:"bytes,2,opt,name=context_info,json=contextInfo,proto3" json:"context_info,omitempty"`
}

func (x *ModelAttributes) Reset() {
	*x = ModelAttributes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ModelAttributes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModelAttributes) ProtoMessage() {}

func (x *ModelAttributes) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModelAttributes.ProtoReflect.Descriptor instead.
func (*ModelAttributes) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{17}
}

func (x *ModelAttributes) GetSampleRate() uint32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

func (x *ModelAttributes) GetContextInfo() *ContextInfo {
	if x != nil {
		return x.ContextInfo
	}
	return nil
}

// Model information specifc to supporting recognition context.
type ContextInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If this is set to true, the model supports taking context information into
	// account to aid speech recognition. The information may be sent with with
	// recognition requests via RecognitionContext inside RecognitionConfig.
	SupportsContext bool `protobuf:"varint,1,opt,name=supports_context,json=supportsContext,proto3" json:"supports_context,omitempty"`
	// A list of tokens (e.g "name", "airport" etc.) that serve has placeholders
	// in the model where a client provided list of phrases or words may be used
	// to aid speech recognition and produce the exact desired recognition output.
	AllowedContextTokens []string `protobuf:"bytes,2,rep,name=allowed_context_tokens,json=allowedContextTokens,proto3" json:"allowed_context_tokens,omitempty"`
}

func (x *ContextInfo) Reset() {
	*x = ContextInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContextInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContextInfo) ProtoMessage() {}

func (x *ContextInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContextInfo.ProtoReflect.Descriptor instead.
func (*ContextInfo) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{18}
}

func (x *ContextInfo) GetSupportsContext() bool {
	if x != nil {
		return x.SupportsContext
	}
	return false
}

func (x *ContextInfo) GetAllowedContextTokens() []string {
	if x != nil {
		return x.AllowedContextTokens
	}
	return nil
}

// A recognition result corresponding to a portion of audio.
type RecognitionResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// An n-best list of recognition hypotheses alternatives
	Alternatives []*RecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
	// If this is set to true, it denotes that the result is an interim partial
	// result, and could change after more audio is processed. If unset, or set to
	// false, it denotes that this is a final result and will not change.
	//
	// Servers are not required to implement support for returning partial
	// results, and clients should generally not depend on their availability.
	IsPartial bool `protobuf:"varint,2,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
	// If `enable_confusion_network` was set to true in the `RecognitionConfig`,
	// and if the model supports it, a confusion network will be available in the
	// results.
	Cnet *RecognitionConfusionNetwork `protobuf:"bytes,3,opt,name=cnet,proto3" json:"cnet,omitempty"`
	// Channel of the audio file that this result was transcribed from. Channels
	// are 0-indexed, so the for mono audio data, this value will always be 0.
	AudioChannel uint32 `protobuf:"varint,4,opt,name=audio_channel,json=audioChannel,proto3" json:"audio_channel,omitempty"`
}

func (x *RecognitionResult) Reset() {
	*x = RecognitionResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionResult) ProtoMessage() {}

func (x *RecognitionResult) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionResult.ProtoReflect.Descriptor instead.
func (*RecognitionResult) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{19}
}

func (x *RecognitionResult) GetAlternatives() []*RecognitionAlternative {
	if x != nil {
		return x.Alternatives
	}
	return nil
}

func (x *RecognitionResult) GetIsPartial() bool {
	if x != nil {
		return x.IsPartial
	}
	return false
}

func (x *RecognitionResult) GetCnet() *RecognitionConfusionNetwork {
	if x != nil {
		return x.Cnet
	}
	return nil
}

func (x *RecognitionResult) GetAudioChannel() uint32 {
	if x != nil {
		return x.AudioChannel
	}
	return 0
}

// Developer-facing error message about a non-fatal recognition issue.
type RecognitionError struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *RecognitionError) Reset() {
	*x = RecognitionError{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionError) ProtoMessage() {}

func (x *RecognitionError) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionError.ProtoReflect.Descriptor instead.
func (*RecognitionError) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{20}
}

func (x *RecognitionError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// A recognition hypothesis
type RecognitionAlternative struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Text representing the transcription of the words that the user spoke.
	//
	// The transcript will be formatted according to the servers formatting
	// configuration. If you want the raw transcript, please see the field
	// `transcript_raw`. If the server is configured to not use any formatting,
	// then this field will contain the raw transcript.
	//
	// As an example, if the spoken utterance was "four people", and the server
	// was configured to format numbers, this field would be set to "4 people".
	TranscriptFormatted string `protobuf:"bytes,1,opt,name=transcript_formatted,json=transcriptFormatted,proto3" json:"transcript_formatted,omitempty"`
	// Text representing the transcription of the words that the user spoke,
	// without any formatting applied. If you want the formatted transcript,
	// please see the field `transcript_formatted`.
	//
	// As an example, if the spoken utterance was `four people`, this field would
	// be set to "FOUR PEOPLE".
	TranscriptRaw string `protobuf:"bytes,2,opt,name=transcript_raw,json=transcriptRaw,proto3" json:"transcript_raw,omitempty"`
	// Time offset in milliseconds relative to the beginning of audio received by
	// the recognizer and corresponding to the start of this utterance.
	StartTimeMs uint64 `protobuf:"varint,3,opt,name=start_time_ms,json=startTimeMs,proto3" json:"start_time_ms,omitempty"`
	// Duration in milliseconds of the current utterance in the spoken audio.
	DurationMs uint64 `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// Confidence estimate between 0 and 1. A higher number represents a higher
	// likelihood of the output being correct.
	Confidence float64 `protobuf:"fixed64,5,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Word-level details corresponding to the transcripts. This is available only
	// if `enable_word_details` was set to `true` in the `RecognitionConfig`.
	WordDetails *WordDetails `protobuf:"bytes,6,opt,name=word_details,json=wordDetails,proto3" json:"word_details,omitempty"`
}

func (x *RecognitionAlternative) Reset() {
	*x = RecognitionAlternative{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionAlternative) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionAlternative) ProtoMessage() {}

func (x *RecognitionAlternative) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionAlternative.ProtoReflect.Descriptor instead.
func (*RecognitionAlternative) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{21}
}

func (x *RecognitionAlternative) GetTranscriptFormatted() string {
	if x != nil {
		return x.TranscriptFormatted
	}
	return ""
}

func (x *RecognitionAlternative) GetTranscriptRaw() string {
	if x != nil {
		return x.TranscriptRaw
	}
	return ""
}

func (x *RecognitionAlternative) GetStartTimeMs() uint64 {
	if x != nil {
		return x.StartTimeMs
	}
	return 0
}

func (x *RecognitionAlternative) GetDurationMs() uint64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *RecognitionAlternative) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *RecognitionAlternative) GetWordDetails() *WordDetails {
	if x != nil {
		return x.WordDetails
	}
	return nil
}

type WordDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Word-level information corresponding to the `transcript_formatted` field.
	Formatted []*WordInfo `protobuf:"bytes,1,rep,name=formatted,proto3" json:"formatted,omitempty"`
	// Word-level information corresponding to the `transcript_raw` field.
	Raw []*WordInfo `protobuf:"bytes,2,rep,name=raw,proto3" json:"raw,omitempty"`
}

func (x *WordDetails) Reset() {
	*x = WordDetails{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WordDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordDetails) ProtoMessage() {}

func (x *WordDetails) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordDetails.ProtoReflect.Descriptor instead.
func (*WordDetails) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{22}
}

func (x *WordDetails) GetFormatted() []*WordInfo {
	if x != nil {
		return x.Formatted
	}
	return nil
}

func (x *WordDetails) GetRaw() []*WordInfo {
	if x != nil {
		return x.Raw
	}
	return nil
}

// Word level details for recognized words in a transcript
type WordInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The actual word in the text
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	// Confidence estimate between 0 and 1. A higher number represents a higher
	// likelihood that the word was correctly recognized.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Time offset in milliseconds relative to the beginning of audio received by
	// the recognizer and corresponding to the start of this spoken word.
	StartTimeMs uint64 `protobuf:"varint,3,opt,name=start_time_ms,json=startTimeMs,proto3" json:"start_time_ms,omitempty"`
	// Duration in milliseconds of the current word in the spoken audio.
	DurationMs uint64 `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
}

func (x *WordInfo) Reset() {
	*x = WordInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WordInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordInfo) ProtoMessage() {}

func (x *WordInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordInfo.ProtoReflect.Descriptor instead.
func (*WordInfo) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{23}
}

func (x *WordInfo) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *WordInfo) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *WordInfo) GetStartTimeMs() uint64 {
	if x != nil {
		return x.StartTimeMs
	}
	return 0
}

func (x *WordInfo) GetDurationMs() uint64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// Confusion network in recognition output
type RecognitionConfusionNetwork struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Links []*ConfusionNetworkLink `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
}

func (x *RecognitionConfusionNetwork) Reset() {
	*x = RecognitionConfusionNetwork{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RecognitionConfusionNetwork) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionConfusionNetwork) ProtoMessage() {}

func (x *RecognitionConfusionNetwork) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionConfusionNetwork.ProtoReflect.Descriptor instead.
func (*RecognitionConfusionNetwork) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{24}
}

func (x *RecognitionConfusionNetwork) GetLinks() []*ConfusionNetworkLink {
	if x != nil {
		return x.Links
	}
	return nil
}

// A Link inside a confusion network
type ConfusionNetworkLink struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Time offset in milliseconds relative to the beginning of audio received by
	// the recognizer and corresponding to the start of this link
	StartTimeMs uint64 `protobuf:"varint,1,opt,name=start_time_ms,json=startTimeMs,proto3" json:"start_time_ms,omitempty"`
	// Duration in milliseconds of the current link in the confusion network
	DurationMs uint64 `protobuf:"varint,2,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// Arcs between this link
	Arcs []*ConfusionNetworkArc `protobuf:"bytes,3,rep,name=arcs,proto3" json:"arcs,omitempty"`
}

func (x *ConfusionNetworkLink) Reset() {
	*x = ConfusionNetworkLink{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConfusionNetworkLink) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfusionNetworkLink) ProtoMessage() {}

func (x *ConfusionNetworkLink) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfusionNetworkLink.ProtoReflect.Descriptor instead.
func (*ConfusionNetworkLink) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{25}
}

func (x *ConfusionNetworkLink) GetStartTimeMs() uint64 {
	if x != nil {
		return x.StartTimeMs
	}
	return 0
}

func (x *ConfusionNetworkLink) GetDurationMs() uint64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *ConfusionNetworkLink) GetArcs() []*ConfusionNetworkArc {
	if x != nil {
		return x.Arcs
	}
	return nil
}

// An Arc inside a Confusion Network Link
type ConfusionNetworkArc struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Word in the recognized transcript
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	// Confidence estimate between 0 and 1. A higher number represents a higher
	// likelihood that the word was correctly recognized.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Features related to this arc
	Features *ConfusionNetworkArcFeatures `protobuf:"bytes,3,opt,name=features,proto3" json:"features,omitempty"`
}

func (x *ConfusionNetworkArc) Reset() {
	*x = ConfusionNetworkArc{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConfusionNetworkArc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfusionNetworkArc) ProtoMessage() {}

func (x *ConfusionNetworkArc) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfusionNetworkArc.ProtoReflect.Descriptor instead.
func (*ConfusionNetworkArc) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{26}
}

func (x *ConfusionNetworkArc) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *ConfusionNetworkArc) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *ConfusionNetworkArc) GetFeatures() *ConfusionNetworkArcFeatures {
	if x != nil {
		return x.Features
	}
	return nil
}

// Features related to confusion network arcs
type ConfusionNetworkArcFeatures struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A map of features that are used for recalculating confidence scores of this
	// confusion network arc
	Confidence map[string]float64 `protobuf:"bytes,1,rep,name=confidence,proto3" json:"confidence,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (x *ConfusionNetworkArcFeatures) Reset() {
	*x = ConfusionNetworkArcFeatures{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConfusionNetworkArcFeatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfusionNetworkArcFeatures) ProtoMessage() {}

func (x *ConfusionNetworkArcFeatures) ProtoReflect() protoreflect.Message {
	mi := &file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfusionNetworkArcFeatures.ProtoReflect.Descriptor instead.
func (*ConfusionNetworkArcFeatures) Descriptor() ([]byte, []int) {
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP(), []int{27}
}

func (x *ConfusionNetworkArcFeatures) GetConfidence() map[string]float64 {
	if x != nil {
		return x.Confidence
	}
	return nil
}

var File_cobaltspeech_cubic_v5_cubic_proto protoreflect.FileDescriptor

var file_cobaltspeech_cubic_v5_cubic_proto_rawDesc = []byte{
	0x0a, 0x21, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2f, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x2f, 0x76, 0x35, 0x2f, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x15, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x10, 0x0a, 0x0e, 0x56, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2b, 0x0a, 0x0f, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a,
	0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x13, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x4d,
	0x6f, 0x64, 0x65, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x4a, 0x0a, 0x12,
	0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c,
	0x52, 0x06, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x22, 0xab, 0x01, 0x0a, 0x19, 0x53, 0x74, 0x72,
	0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x42, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x48, 0x00, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3f, 0x0a, 0x05, 0x61, 0x75,
	0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x62, 0x61,
	0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76,
	0x35, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x75, 0x64,
	0x69, 0x6f, 0x48, 0x00, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x42, 0x09, 0x0a, 0x07, 0x72,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x9d, 0x01, 0x0a, 0x1a, 0x53, 0x74, 0x72, 0x65, 0x61,
	0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52,
	0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x3d, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52,
	0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x88, 0x01, 0x0a, 0x15, 0x43, 0x6f, 0x6d, 0x70, 0x69,
	0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x19, 0x0a, 0x08, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x12, 0x3e, 0x0a, 0x07, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x24, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65,
	0x78, 0x74, 0x50, 0x68, 0x72, 0x61, 0x73, 0x65, 0x52, 0x07, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65,
	0x73, 0x22, 0x5a, 0x0a, 0x16, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a, 0x07, 0x63,
	0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f, 0x6e,
	0x74, 0x65, 0x78, 0x74, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x22, 0xd5, 0x03,
	0x0a, 0x11, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x12, 0x19, 0x0a, 0x08, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x45,
	0x0a, 0x0c, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x41, 0x75, 0x64,
	0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0b, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x36, 0x0a, 0x17, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x65,
	0x64, 0x5f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x15, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64,
	0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x2f, 0x0a,
	0x14, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x5f, 0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x61, 0x75, 0x64,
	0x69, 0x6f, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x4d, 0x73, 0x12, 0x2e,
	0x0a, 0x13, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x64, 0x65,
	0x74, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x65, 0x6e, 0x61,
	0x62, 0x6c, 0x65, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x38,
	0x0a, 0x18, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69,
	0x6f, 0x6e, 0x5f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x16, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f,
	0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x46, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e,
	0x76, 0x35, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x12, 0x43, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x07, 0x63, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x22, 0xed, 0x01, 0x0a, 0x0b, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x3b, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65,
	0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x41, 0x75, 0x64, 0x69,
	0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79,
	0x70, 0x65, 0x12, 0x37, 0x0a, 0x03, 0x72, 0x61, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72,
	0x6d, 0x61, 0x74, 0x52, 0x61, 0x77, 0x52, 0x03, 0x72, 0x61, 0x77, 0x22, 0x68, 0x0a, 0x04, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50,
	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x52, 0x41, 0x57, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x57, 0x41, 0x56, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d, 0x50,
	0x33, 0x10, 0x03, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x4c, 0x41, 0x43,
	0x10, 0x04, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x47, 0x47, 0x5f, 0x4f,
	0x50, 0x55, 0x53, 0x10, 0x05, 0x22, 0xed, 0x01, 0x0a, 0x0e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x61, 0x77, 0x12, 0x40, 0x0a, 0x08, 0x65, 0x6e, 0x63, 0x6f,
	0x64, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e,
	0x76, 0x35, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67,
	0x52, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x1b, 0x0a, 0x09, 0x62, 0x69,
	0x74, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x62,
	0x69, 0x74, 0x44, 0x65, 0x70, 0x74, 0x68, 0x12, 0x3f, 0x0a, 0x0a, 0x62, 0x79, 0x74, 0x65, 0x5f,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f,
	0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63,
	0x2e, 0x76, 0x35, 0x2e, 0x42, 0x79, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x09, 0x62,
	0x79, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x61, 0x6d, 0x70,
	0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x73,
	0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x61, 0x74, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x63, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x22, 0x3e, 0x0a, 0x13, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x27, 0x0a, 0x0f,
	0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x58, 0x0a, 0x12, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12, 0x42, 0x0a, 0x08, 0x63,
	0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e,
	0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62,
	0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x08, 0x63, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x64, 0x22,
	0x25, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x74, 0x65,
	0x78, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0x39, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78,
	0x74, 0x50, 0x68, 0x72, 0x61, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x62,
	0x6f, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x62, 0x6f, 0x6f, 0x73,
	0x74, 0x22, 0x26, 0x0a, 0x10, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0x73, 0x0a, 0x05, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x46, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62,
	0x75, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e,
	0x76, 0x35, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74,
	0x65, 0x73, 0x52, 0x0a, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x22, 0x79,
	0x0a, 0x0f, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65,
	0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x61,
	0x74, 0x65, 0x12, 0x45, 0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c,
	0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35,
	0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0b, 0x63, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x6e, 0x0a, 0x0b, 0x43, 0x6f, 0x6e,
	0x74, 0x65, 0x78, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x29, 0x0a, 0x10, 0x73, 0x75, 0x70, 0x70,
	0x6f, 0x72, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0f, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x43, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x12, 0x34, 0x0a, 0x16, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x63,
	0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x14, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x22, 0xf2, 0x01, 0x0a, 0x11, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12,
	0x51, 0x0a, 0x0c, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70,
	0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61,
	0x74, 0x69, 0x76, 0x65, 0x52, 0x0c, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76,
	0x65, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61,
	0x6c, 0x12, 0x46, 0x0a, 0x04, 0x63, 0x6e, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x52, 0x04, 0x63, 0x6e, 0x65, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x75, 0x64,
	0x69, 0x6f, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x22, 0x2c,
	0x0a, 0x10, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x72, 0x72,
	0x6f, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x9e, 0x02, 0x0a,
	0x16, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6c, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x12, 0x31, 0x0a, 0x14, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70,
	0x74, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x72,
	0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x5f, 0x72, 0x61, 0x77, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x52, 0x61,
	0x77, 0x12, 0x22, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f,
	0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54,
	0x69, 0x6d, 0x65, 0x4d, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x64, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64,
	0x65, 0x6e, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x45, 0x0a, 0x0c, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x64,
	0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73,
	0x52, 0x0b, 0x77, 0x6f, 0x72, 0x64, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0x7f, 0x0a,
	0x0b, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x3d, 0x0a, 0x09,
	0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63,
	0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x57, 0x6f, 0x72, 0x64, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x09, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x64, 0x12, 0x31, 0x0a, 0x03, 0x72,
	0x61, 0x77, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c,
	0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35,
	0x2e, 0x57, 0x6f, 0x72, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x03, 0x72, 0x61, 0x77, 0x22, 0x83,
	0x01, 0x0a, 0x08, 0x57, 0x6f, 0x72, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x77,
	0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x77, 0x6f, 0x72, 0x64, 0x12,
	0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12,
	0x22, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6d, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d,
	0x65, 0x4d, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x4d, 0x73, 0x22, 0x60, 0x0a, 0x1b, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x12, 0x41, 0x0a, 0x05, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x75,
	0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4c, 0x69, 0x6e, 0x6b, 0x52,
	0x05, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x22, 0x9b, 0x01, 0x0a, 0x14, 0x43, 0x6f, 0x6e, 0x66, 0x75,
	0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4c, 0x69, 0x6e, 0x6b, 0x12,
	0x22, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6d, 0x73,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d,
	0x65, 0x4d, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x6d, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x4d, 0x73, 0x12, 0x3e, 0x0a, 0x04, 0x61, 0x72, 0x63, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x75,
	0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x72, 0x63, 0x52, 0x04,
	0x61, 0x72, 0x63, 0x73, 0x22, 0x99, 0x01, 0x0a, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69,
	0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x72, 0x63, 0x12, 0x12, 0x0a, 0x04,
	0x77, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x77, 0x6f, 0x72, 0x64,
	0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65,
	0x12, 0x4e, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x32, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x75,
	0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x72, 0x63, 0x46, 0x65,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
	0x22, 0xc0, 0x01, 0x0a, 0x1b, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x72, 0x63, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
	0x12, 0x62, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x42, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6e,
	0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x72, 0x63,
	0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65,
	0x6e, 0x63, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64,
	0x65, 0x6e, 0x63, 0x65, 0x1a, 0x3d, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e,
	0x63, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x2a, 0x60, 0x0a, 0x09, 0x42, 0x79, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x12, 0x1a, 0x0a, 0x16, 0x42, 0x59, 0x54, 0x45, 0x5f, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18,
	0x42, 0x59, 0x54, 0x45, 0x5f, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x4c, 0x49, 0x54, 0x54, 0x4c,
	0x45, 0x5f, 0x45, 0x4e, 0x44, 0x49, 0x41, 0x4e, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x42, 0x59,
	0x54, 0x45, 0x5f, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x42, 0x49, 0x47, 0x5f, 0x45, 0x4e, 0x44,
	0x49, 0x41, 0x4e, 0x10, 0x02, 0x2a, 0xb8, 0x01, 0x0a, 0x0d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x45,
	0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x1e, 0x0a, 0x1a, 0x41, 0x55, 0x44, 0x49, 0x4f,
	0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x41, 0x55, 0x44, 0x49, 0x4f,
	0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x49, 0x47, 0x4e, 0x45, 0x44,
	0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x5f, 0x45, 0x4e, 0x43, 0x4f,
	0x44, 0x49, 0x4e, 0x47, 0x5f, 0x55, 0x4e, 0x53, 0x49, 0x47, 0x4e, 0x45, 0x44, 0x10, 0x02, 0x12,
	0x1d, 0x0a, 0x19, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e,
	0x47, 0x5f, 0x49, 0x45, 0x45, 0x45, 0x5f, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x10, 0x03, 0x12, 0x17,
	0x0a, 0x13, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47,
	0x5f, 0x55, 0x4c, 0x41, 0x57, 0x10, 0x04, 0x12, 0x17, 0x0a, 0x13, 0x41, 0x55, 0x44, 0x49, 0x4f,
	0x5f, 0x45, 0x4e, 0x43, 0x4f, 0x44, 0x49, 0x4e, 0x47, 0x5f, 0x41, 0x4c, 0x41, 0x57, 0x10, 0x05,
	0x32, 0xab, 0x04, 0x0a, 0x0c, 0x43, 0x75, 0x62, 0x69, 0x63, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x12, 0x71, 0x0a, 0x07, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x25, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65,
	0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x56, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x17, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x11, 0x12, 0x0f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x35, 0x2f, 0x76, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x12, 0x7d, 0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x65,
	0x6c, 0x73, 0x12, 0x28, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63,
	0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d,
	0x6f, 0x64, 0x65, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x29, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x12,
	0x12, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x35, 0x2f, 0x6c, 0x69, 0x73, 0x74, 0x6d, 0x6f, 0x64,
	0x65, 0x6c, 0x73, 0x12, 0x95, 0x01, 0x0a, 0x12, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e,
	0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x12, 0x30, 0x2e, 0x63, 0x6f, 0x62,
	0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e,
	0x76, 0x35, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f,
	0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x31, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x16, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x35,
	0x2f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x28, 0x01, 0x30, 0x01, 0x12, 0x90, 0x01, 0x0a, 0x0e,
	0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12, 0x2c,
	0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75,
	0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x63,
	0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69,
	0x63, 0x2e, 0x76, 0x35, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74,
	0x65, 0x78, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x21, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x1b, 0x22, 0x16, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x35, 0x2f, 0x63, 0x6f, 0x6d,
	0x70, 0x69, 0x6c, 0x65, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x3a, 0x01, 0x2a, 0x42, 0xe0,
	0x01, 0x0a, 0x19, 0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2e, 0x63, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x76, 0x35, 0x42, 0x0a, 0x43, 0x75,
	0x62, 0x69, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x41, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x2f, 0x67, 0x6f, 0x2d, 0x67, 0x65, 0x6e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
	0x63, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x2f, 0x63, 0x75, 0x62,
	0x69, 0x63, 0x2f, 0x76, 0x35, 0x3b, 0x63, 0x75, 0x62, 0x69, 0x63, 0x76, 0x35, 0xa2, 0x02, 0x03,
	0x43, 0x43, 0x58, 0xaa, 0x02, 0x15, 0x43, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65,
	0x63, 0x68, 0x2e, 0x43, 0x75, 0x62, 0x69, 0x63, 0x2e, 0x56, 0x35, 0xca, 0x02, 0x15, 0x43, 0x6f,
	0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x5c, 0x43, 0x75, 0x62, 0x69, 0x63,
	0x5c, 0x56, 0x35, 0xe2, 0x02, 0x21, 0x43, 0x6f, 0x62, 0x61, 0x6c, 0x74, 0x73, 0x70, 0x65, 0x65,
	0x63, 0x68, 0x5c, 0x43, 0x75, 0x62, 0x69, 0x63, 0x5c, 0x56, 0x35, 0x5c, 0x47, 0x50, 0x42, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x17, 0x43, 0x6f, 0x62, 0x61, 0x6c, 0x74,
	0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x3a, 0x3a, 0x43, 0x75, 0x62, 0x69, 0x63, 0x3a, 0x3a, 0x56,
	0x35, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_cobaltspeech_cubic_v5_cubic_proto_rawDescOnce sync.Once
	file_cobaltspeech_cubic_v5_cubic_proto_rawDescData = file_cobaltspeech_cubic_v5_cubic_proto_rawDesc
)

func file_cobaltspeech_cubic_v5_cubic_proto_rawDescGZIP() []byte {
	file_cobaltspeech_cubic_v5_cubic_proto_rawDescOnce.Do(func() {
		file_cobaltspeech_cubic_v5_cubic_proto_rawDescData = protoimpl.X.CompressGZIP(file_cobaltspeech_cubic_v5_cubic_proto_rawDescData)
	})
	return file_cobaltspeech_cubic_v5_cubic_proto_rawDescData
}

var file_cobaltspeech_cubic_v5_cubic_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_cobaltspeech_cubic_v5_cubic_proto_msgTypes = make([]protoimpl.MessageInfo, 29)
var file_cobaltspeech_cubic_v5_cubic_proto_goTypes = []interface{}{
	(ByteOrder)(0),                      // 0: cobaltspeech.cubic.v5.ByteOrder
	(AudioEncoding)(0),                  // 1: cobaltspeech.cubic.v5.AudioEncoding
	(AudioFormat_Type)(0),               // 2: cobaltspeech.cubic.v5.AudioFormat.Type
	(*VersionRequest)(nil),              // 3: cobaltspeech.cubic.v5.VersionRequest
	(*VersionResponse)(nil),             // 4: cobaltspeech.cubic.v5.VersionResponse
	(*ListModelsRequest)(nil),           // 5: cobaltspeech.cubic.v5.ListModelsRequest
	(*ListModelsResponse)(nil),          // 6: cobaltspeech.cubic.v5.ListModelsResponse
	(*StreamingRecognizeRequest)(nil),   // 7: cobaltspeech.cubic.v5.StreamingRecognizeRequest
	(*StreamingRecognizeResponse)(nil),  // 8: cobaltspeech.cubic.v5.StreamingRecognizeResponse
	(*CompileContextRequest)(nil),       // 9: cobaltspeech.cubic.v5.CompileContextRequest
	(*CompileContextResponse)(nil),      // 10: cobaltspeech.cubic.v5.CompileContextResponse
	(*RecognitionConfig)(nil),           // 11: cobaltspeech.cubic.v5.RecognitionConfig
	(*AudioFormat)(nil),                 // 12: cobaltspeech.cubic.v5.AudioFormat
	(*AudioFormatRaw)(nil),              // 13: cobaltspeech.cubic.v5.AudioFormatRaw
	(*RecognitionMetadata)(nil),         // 14: cobaltspeech.cubic.v5.RecognitionMetadata
	(*RecognitionContext)(nil),          // 15: cobaltspeech.cubic.v5.RecognitionContext
	(*CompiledContext)(nil),             // 16: cobaltspeech.cubic.v5.CompiledContext
	(*ContextPhrase)(nil),               // 17: cobaltspeech.cubic.v5.ContextPhrase
	(*RecognitionAudio)(nil),            // 18: cobaltspeech.cubic.v5.RecognitionAudio
	(*Model)(nil),                       // 19: cobaltspeech.cubic.v5.Model
	(*ModelAttributes)(nil),             // 20: cobaltspeech.cubic.v5.ModelAttributes
	(*ContextInfo)(nil),                 // 21: cobaltspeech.cubic.v5.ContextInfo
	(*RecognitionResult)(nil),           // 22: cobaltspeech.cubic.v5.RecognitionResult
	(*RecognitionError)(nil),            // 23: cobaltspeech.cubic.v5.RecognitionError
	(*RecognitionAlternative)(nil),      // 24: cobaltspeech.cubic.v5.RecognitionAlternative
	(*WordDetails)(nil),                 // 25: cobaltspeech.cubic.v5.WordDetails
	(*WordInfo)(nil),                    // 26: cobaltspeech.cubic.v5.WordInfo
	(*RecognitionConfusionNetwork)(nil), // 27: cobaltspeech.cubic.v5.RecognitionConfusionNetwork
	(*ConfusionNetworkLink)(nil),        // 28: cobaltspeech.cubic.v5.ConfusionNetworkLink
	(*ConfusionNetworkArc)(nil),         // 29: cobaltspeech.cubic.v5.ConfusionNetworkArc
	(*ConfusionNetworkArcFeatures)(nil), // 30: cobaltspeech.cubic.v5.ConfusionNetworkArcFeatures
	nil,                                 // 31: cobaltspeech.cubic.v5.ConfusionNetworkArcFeatures.ConfidenceEntry
}
var file_cobaltspeech_cubic_v5_cubic_proto_depIdxs = []int32{
	19, // 0: cobaltspeech.cubic.v5.ListModelsResponse.models:type_name -> cobaltspeech.cubic.v5.Model
	11, // 1: cobaltspeech.cubic.v5.StreamingRecognizeRequest.config:type_name -> cobaltspeech.cubic.v5.RecognitionConfig
	18, // 2: cobaltspeech.cubic.v5.StreamingRecognizeRequest.audio:type_name -> cobaltspeech.cubic.v5.RecognitionAudio
	22, // 3: cobaltspeech.cubic.v5.StreamingRecognizeResponse.result:type_name -> cobaltspeech.cubic.v5.RecognitionResult
	23, // 4: cobaltspeech.cubic.v5.StreamingRecognizeResponse.error:type_name -> cobaltspeech.cubic.v5.RecognitionError
	17, // 5: cobaltspeech.cubic.v5.CompileContextRequest.phrases:type_name -> cobaltspeech.cubic.v5.ContextPhrase
	16, // 6: cobaltspeech.cubic.v5.CompileContextResponse.context:type_name -> cobaltspeech.cubic.v5.CompiledContext
	12, // 7: cobaltspeech.cubic.v5.RecognitionConfig.audio_format:type_name -> cobaltspeech.cubic.v5.AudioFormat
	14, // 8: cobaltspeech.cubic.v5.RecognitionConfig.metadata:type_name -> cobaltspeech.cubic.v5.RecognitionMetadata
	15, // 9: cobaltspeech.cubic.v5.RecognitionConfig.context:type_name -> cobaltspeech.cubic.v5.RecognitionContext
	2,  // 10: cobaltspeech.cubic.v5.AudioFormat.type:type_name -> cobaltspeech.cubic.v5.AudioFormat.Type
	13, // 11: cobaltspeech.cubic.v5.AudioFormat.raw:type_name -> cobaltspeech.cubic.v5.AudioFormatRaw
	1,  // 12: cobaltspeech.cubic.v5.AudioFormatRaw.encoding:type_name -> cobaltspeech.cubic.v5.AudioEncoding
	0,  // 13: cobaltspeech.cubic.v5.AudioFormatRaw.byte_order:type_name -> cobaltspeech.cubic.v5.ByteOrder
	16, // 14: cobaltspeech.cubic.v5.RecognitionContext.compiled:type_name -> cobaltspeech.cubic.v5.CompiledContext
	20, // 15: cobaltspeech.cubic.v5.Model.attributes:type_name -> cobaltspeech.cubic.v5.ModelAttributes
	21, // 16: cobaltspeech.cubic.v5.ModelAttributes.context_info:type_name -> cobaltspeech.cubic.v5.ContextInfo
	24, // 17: cobaltspeech.cubic.v5.RecognitionResult.alternatives:type_name -> cobaltspeech.cubic.v5.RecognitionAlternative
	27, // 18: cobaltspeech.cubic.v5.RecognitionResult.cnet:type_name -> cobaltspeech.cubic.v5.RecognitionConfusionNetwork
	25, // 19: cobaltspeech.cubic.v5.RecognitionAlternative.word_details:type_name -> cobaltspeech.cubic.v5.WordDetails
	26, // 20: cobaltspeech.cubic.v5.WordDetails.formatted:type_name -> cobaltspeech.cubic.v5.WordInfo
	26, // 21: cobaltspeech.cubic.v5.WordDetails.raw:type_name -> cobaltspeech.cubic.v5.WordInfo
	28, // 22: cobaltspeech.cubic.v5.RecognitionConfusionNetwork.links:type_name -> cobaltspeech.cubic.v5.ConfusionNetworkLink
	29, // 23: cobaltspeech.cubic.v5.ConfusionNetworkLink.arcs:type_name -> cobaltspeech.cubic.v5.ConfusionNetworkArc
	30, // 24: cobaltspeech.cubic.v5.ConfusionNetworkArc.features:type_name -> cobaltspeech.cubic.v5.ConfusionNetworkArcFeatures
	31, // 25: cobaltspeech.cubic.v5.ConfusionNetworkArcFeatures.confidence:type_name -> cobaltspeech.cubic.v5.ConfusionNetworkArcFeatures.ConfidenceEntry
	3,  // 26: cobaltspeech.cubic.v5.CubicService.Version:input_type -> cobaltspeech.cubic.v5.VersionRequest
	5,  // 27: cobaltspeech.cubic.v5.CubicService.ListModels:input_type -> cobaltspeech.cubic.v5.ListModelsRequest
	7,  // 28: cobaltspeech.cubic.v5.CubicService.StreamingRecognize:input_type -> cobaltspeech.cubic.v5.StreamingRecognizeRequest
	9,  // 29: cobaltspeech.cubic.v5.CubicService.CompileContext:input_type -> cobaltspeech.cubic.v5.CompileContextRequest
	4,  // 30: cobaltspeech.cubic.v5.CubicService.Version:output_type -> cobaltspeech.cubic.v5.VersionResponse
	6,  // 31: cobaltspeech.cubic.v5.CubicService.ListModels:output_type -> cobaltspeech.cubic.v5.ListModelsResponse
	8,  // 32: cobaltspeech.cubic.v5.CubicService.StreamingRecognize:output_type -> cobaltspeech.cubic.v5.StreamingRecognizeResponse
	10, // 33: cobaltspeech.cubic.v5.CubicService.CompileContext:output_type -> cobaltspeech.cubic.v5.CompileContextResponse
	30, // [30:34] is the sub-list for method output_type
	26, // [26:30] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_cobaltspeech_cubic_v5_cubic_proto_init() }
func file_cobaltspeech_cubic_v5_cubic_proto_init() {
	if File_cobaltspeech_cubic_v5_cubic_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VersionRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VersionResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListModelsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListModelsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StreamingRecognizeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StreamingRecognizeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompileContextRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompileContextResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AudioFormat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AudioFormatRaw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionContext); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompiledContext); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContextPhrase); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionAudio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Model); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ModelAttributes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContextInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionError); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionAlternative); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WordDetails); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WordInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RecognitionConfusionNetwork); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConfusionNetworkLink); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConfusionNetworkArc); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConfusionNetworkArcFeatures); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_cobaltspeech_cubic_v5_cubic_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*StreamingRecognizeRequest_Config)(nil),
		(*StreamingRecognizeRequest_Audio)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cobaltspeech_cubic_v5_cubic_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   29,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_cobaltspeech_cubic_v5_cubic_proto_goTypes,
		DependencyIndexes: file_cobaltspeech_cubic_v5_cubic_proto_depIdxs,
		EnumInfos:         file_cobaltspeech_cubic_v5_cubic_proto_enumTypes,
		MessageInfos:      file_cobaltspeech_cubic_v5_cubic_proto_msgTypes,
	}.Build()
	File_cobaltspeech_cubic_v5_cubic_proto = out.File
	file_cobaltspeech_cubic_v5_cubic_proto_rawDesc = nil
	file_cobaltspeech_cubic_v5_cubic_proto_goTypes = nil
	file_cobaltspeech_cubic_v5_cubic_proto_depIdxs = nil
}
